暂时性死区：

es6语法中，函数参数可以设置默认值，默认值可以是确定的值也可以是表达式，而且默认参数为表达式时表达式是惰性求值，只有在执行函数时才会执行该表达式。

执行函数时，如果参数传递是undefined则将触发默认值，传null没有这个效果。

函数的length属性将返回没有设置默认值的参数的个数，如果函数设置了默认值，length属性将失真。

函数的length属性算的长度不包括rest属性。

利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。
function（param = getWarning()）{}
function getWarning(){throw new Error("miss param")}

es6引入rest参数，通过（...变量名）来获取剩下的参数，可以代替Array.prototype.slice.call(arguments)操作。

从 ES5 开始，函数内部可以设定为严格模式，ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能用'use strict'显式设定为严格模式，否则会报错。
因为函数的严格模式同样限制参数的执行，然而严格模式定义在函数体内，只有参数执行完才能判断是否是严格模式。
两种方法可以规避这种限制：
第一种是设定全局性的严格模式，这是合法的。
第二种是把函数包在一个无参数的立即执行函数里面。

箭头函数与普通函数的区别：
箭头函数使得函数表达式更加简洁。
箭头函数内的this就是指向定义函数时所在的对象，而不是调用函数所绑定的对象。
箭头函数里的this固定化，很适合做回调函数，因为回调函数一般都是在全局作用域下执行，这样很容易找不到需要执行的方法。
箭头函数不可以当作构造函数，也不可以new，否则会报错。
箭头函数不可以使用arguments变量，该变量在箭头函数内部不存在，可以使用rest变量代替。
箭头函数不可以使用yield命令，因此箭头函数不可以作为generator函数。
